/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ npm install @boundaryml/baml
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code

import { FieldType } from '@boundaryml/baml/native'
import { TypeBuilder as _TypeBuilder, EnumBuilder, EnumViewer, ClassBuilder, ClassViewer } from '@boundaryml/baml/type_builder'
import { DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME } from "./globals"

export { FieldType, EnumBuilder, ClassBuilder }

export default class TypeBuilder {
    private tb: _TypeBuilder;
    
    Draft: ClassViewer<'Draft', "frontmatter" | "content" | "markdownContent" | "faqBlocks" | "howtoBlocks">;
    
    EATSignals: ClassViewer<'EATSignals', "authorBio" | "reviewer" | "factChecked" | "reviewDate">;
    
    Evidence: ClassViewer<'Evidence', "claims" | "citations" | "expertQuotes">;
    
    Expanded: ClassViewer<'Expanded', "frontmatter" | "content" | "markdownContent" | "evidence" | "imagePlaceholders" | "eatSignals" | "qualityMetrics">;
    
    FAQ: ClassViewer<'FAQ', "q" | "a" | "a_outline">;
    
    FAQBlock: ClassViewer<'FAQBlock', "question" | "answer">;
    
    Final: ClassViewer<'Final', "frontmatter" | "content" | "markdownContent" | "evidence" | "imagePlaceholders" | "eatSignals" | "qualityMetrics" | "seoOptimizations">;
    
    Frontmatter: ClassViewer<'Frontmatter', "title" | "description" | "slug" | "date" | "author" | "tags" | "category" | "funnel" | "intent" | "primaryKeyword" | "secondaryKeywords" | "wordcount" | "readingTime" | "schema">;
    
    Heading: ClassViewer<'Heading', "h2" | "keypoints" | "h3">;
    
    HowToBlock: ClassViewer<'HowToBlock', "title" | "steps">;
    
    HowToStep: ClassViewer<'HowToStep', "step" | "description" | "text">;
    
    ImagePlaceholder: ClassViewer<'ImagePlaceholder', "altText" | "position" | "description">;
    
    Metadata: ClassViewer<'Metadata', "primaryKeyword" | "secondaryKeywords" | "wordcountTarget" | "readingTime" | "difficulty">;
    
    Outline: ClassViewer<'Outline', "title" | "slug" | "cluster" | "funnel" | "intent" | "tpb" | "targetReader" | "headings" | "faqs" | "metadata">;
    
    Published: ClassViewer<'Published', "frontmatter" | "content" | "markdownContent" | "filePath" | "backupPath" | "validation">;
    
    QualityMetrics: ClassViewer<'QualityMetrics', "readabilityGrade" | "fleschKincaidScore" | "averageSentenceLength" | "passiveVoicePercent" | "keywordDensity" | "brandVoiceAlignment" | "toneAlignment">;
    
    SEOOptimizations: ClassViewer<'SEOOptimizations', "titleOptimized" | "metaDescriptionOptimized" | "schemaMarkupGenerated" | "ctaIncluded" | "keywordDensityOptimized">;
    
    
    FunnelStage: EnumViewer<'FunnelStage', "TOF" | "MOF" | "BOF">;
    
    SearchIntent: EnumViewer<'SearchIntent', "Informational" | "Comparative" | "Transactional">;
    
    TPBClassification: EnumViewer<'TPBClassification', "Attitude" | "Norm" | "Perceived_control">;
    

    constructor() {
        this.tb = new _TypeBuilder({
          classes: new Set([
            "Draft","EATSignals","Evidence","Expanded","FAQ","FAQBlock","Final","Frontmatter","Heading","HowToBlock","HowToStep","ImagePlaceholder","Metadata","Outline","Published","QualityMetrics","SEOOptimizations",
          ]),
          enums: new Set([
            "FunnelStage","SearchIntent","TPBClassification",
          ]),
          runtime: DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME
        });
        
        this.Draft = this.tb.classViewer("Draft", [
          "frontmatter","content","markdownContent","faqBlocks","howtoBlocks",
        ]);
        
        this.EATSignals = this.tb.classViewer("EATSignals", [
          "authorBio","reviewer","factChecked","reviewDate",
        ]);
        
        this.Evidence = this.tb.classViewer("Evidence", [
          "claims","citations","expertQuotes",
        ]);
        
        this.Expanded = this.tb.classViewer("Expanded", [
          "frontmatter","content","markdownContent","evidence","imagePlaceholders","eatSignals","qualityMetrics",
        ]);
        
        this.FAQ = this.tb.classViewer("FAQ", [
          "q","a","a_outline",
        ]);
        
        this.FAQBlock = this.tb.classViewer("FAQBlock", [
          "question","answer",
        ]);
        
        this.Final = this.tb.classViewer("Final", [
          "frontmatter","content","markdownContent","evidence","imagePlaceholders","eatSignals","qualityMetrics","seoOptimizations",
        ]);
        
        this.Frontmatter = this.tb.classViewer("Frontmatter", [
          "title","description","slug","date","author","tags","category","funnel","intent","primaryKeyword","secondaryKeywords","wordcount","readingTime","schema",
        ]);
        
        this.Heading = this.tb.classViewer("Heading", [
          "h2","keypoints","h3",
        ]);
        
        this.HowToBlock = this.tb.classViewer("HowToBlock", [
          "title","steps",
        ]);
        
        this.HowToStep = this.tb.classViewer("HowToStep", [
          "step","description","text",
        ]);
        
        this.ImagePlaceholder = this.tb.classViewer("ImagePlaceholder", [
          "altText","position","description",
        ]);
        
        this.Metadata = this.tb.classViewer("Metadata", [
          "primaryKeyword","secondaryKeywords","wordcountTarget","readingTime","difficulty",
        ]);
        
        this.Outline = this.tb.classViewer("Outline", [
          "title","slug","cluster","funnel","intent","tpb","targetReader","headings","faqs","metadata",
        ]);
        
        this.Published = this.tb.classViewer("Published", [
          "frontmatter","content","markdownContent","filePath","backupPath","validation",
        ]);
        
        this.QualityMetrics = this.tb.classViewer("QualityMetrics", [
          "readabilityGrade","fleschKincaidScore","averageSentenceLength","passiveVoicePercent","keywordDensity","brandVoiceAlignment","toneAlignment",
        ]);
        
        this.SEOOptimizations = this.tb.classViewer("SEOOptimizations", [
          "titleOptimized","metaDescriptionOptimized","schemaMarkupGenerated","ctaIncluded","keywordDensityOptimized",
        ]);
        
        
        this.FunnelStage = this.tb.enumViewer("FunnelStage", [
          "TOF","MOF","BOF",
        ]);
        
        this.SearchIntent = this.tb.enumViewer("SearchIntent", [
          "Informational","Comparative","Transactional",
        ]);
        
        this.TPBClassification = this.tb.enumViewer("TPBClassification", [
          "Attitude","Norm","Perceived_control",
        ]);
        
    }

    reset(): void {
        this.tb.reset();
        // TODO: This should happen in Rust. Problem is, when we construct the
        // typebuilder we instantiate class builders once and it seems to make
        // a JS copy, bypassing the Rust side? In Python however, every time we
        // access a class builder with @property, we get a new instance that
        // wraps over the Rust type builder, so we only need to call tb.reset().
        // In JS it's not possible unless we refactor the way class builders are
        // accessed.
        
    }

    __tb() {
      return this.tb._tb();
    }

    string(): FieldType {
        return this.tb.string()
    }

    literalString(value: string): FieldType {
        return this.tb.literalString(value)
    }

    literalInt(value: number): FieldType {
        return this.tb.literalInt(value)
    }

    literalBool(value: boolean): FieldType {
        return this.tb.literalBool(value)
    }

    int(): FieldType {
        return this.tb.int()
    }

    float(): FieldType {
        return this.tb.float()
    }

    bool(): FieldType {
        return this.tb.bool()
    }

    list(type: FieldType): FieldType {
        return this.tb.list(type)
    }

    null(): FieldType {
        return this.tb.null()
    }

    map(key: FieldType, value: FieldType): FieldType {
        return this.tb.map(key, value)
    }

    union(types: FieldType[]): FieldType {
        return this.tb.union(types)
    }

    addClass<Name extends string>(name: Name): ClassBuilder<Name> {
        return this.tb.addClass(name);
    }

    addEnum<Name extends string>(name: Name): EnumBuilder<Name> {
        return this.tb.addEnum(name);
    }

    addBaml(baml: string): void {
        this.tb.addBaml(baml);
    }
}